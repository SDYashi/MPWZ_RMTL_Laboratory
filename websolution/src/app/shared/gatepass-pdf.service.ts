// src/app/services/gatepass-pdf.service.ts
import { Injectable } from '@angular/core';
import pdfMake from 'pdfmake/build/pdfmake';
import pdfFonts from 'pdfmake/build/vfs_fonts';
(pdfMake as any).vfs = pdfFonts.vfs;

export interface GatepassData {
  id?: string | number;
  dispatch_number?: string;
  dispatch_to?: string;
  vehicle?: string;
  report_ids?: string;
  receiver_name?: string;
  receiver_designation?: string;
  receiver_mobile?: string;
  created_by?: string;
  created_at?: string;       // ISO string
  serial_numbers?: string;   // comma-separated serials
}

export interface GatepassDeviceRow {
  serial_number?: string;
  make?: string;
  test_result?: string;
  test_status?: string;
}

export interface GatepassPdfOptions {
  title?: string;                 // default: 'RMTL Gatepass'
  orgName?: string;               // default: 'M.P. Paschim Kshetra Vidyut Vitran Co. Ltd'
  columns?: number;               // default: 3 (serial columns)
  includeNotes?: boolean;         // default: true
  notesText?: string;             // default standard notes
  logoDataUrl?: string;           // optional base64 logo
  devices?: GatepassDeviceRow[];  // optional device table
  deviceTable?: boolean;          // default: false
  fileName?: string;              // optional filename
  generatedBy?: string;           // NEW: "Laboratory User Generated By"
  supportEmail?: string;          // NEW: default 'rmtl@mpwz.co.in'
  showFooterMeta?: boolean;       // NEW: default true
}

type TDocumentDefinition = any;

@Injectable({ providedIn: 'root' })
export class GatepassPdfService {

  download(gp: GatepassData, opts: GatepassPdfOptions = {}): void {
    const doc = this.buildDoc(gp, opts);
    const fname = this.fileName(gp, opts);
    pdfMake.createPdf(doc).download(fname);
  }

  open(gp: GatepassData, opts: GatepassPdfOptions = {}): void {
    const doc = this.buildDoc(gp, opts);
    pdfMake.createPdf(doc).open();
  }

  print(gp: GatepassData, opts: GatepassPdfOptions = {}): void {
    const doc = this.buildDoc(gp, opts);
    pdfMake.createPdf(doc).print();
  }

  getDocDefinition(gp: GatepassData, opts: GatepassPdfOptions = {}): TDocumentDefinition {
    return this.buildDoc(gp, opts);
  }

  // ------------------ Internals ------------------

  private buildDoc(gp: GatepassData, opts: GatepassPdfOptions): TDocumentDefinition {
    const {
      title = 'RMTL Gatepass',
      orgName = 'M.P. Paschim Kshetra Vidyut Vitran Co. Ltd',
      columns = 3,
      includeNotes = true,
      notesText = '— Carry out standard handling and verification on receipt.\n— Any discrepancy must be reported immediately.',
      logoDataUrl,
      devices,
      deviceTable = false,
      generatedBy,
      supportEmail = 'rmtl@mpwz.co.in',
      showFooterMeta = true,
    } = opts;

    const createdAt = gp.created_at ? new Date(gp.created_at) : new Date();
    const createdAtStr = createdAt.toLocaleString();
    const serials = this.parseSerials(gp.serial_numbers || '');

    const headerLeftStack: any[] = [];
    if (logoDataUrl) headerLeftStack.push({ image: logoDataUrl, width: 60, height: 60, margin: [0, 0, 0, 6] });
    headerLeftStack.push({ text: title, style: 'h1' });
    headerLeftStack.push({ text: orgName, style: 'sub' });

    const headerRightStack: any[] = [
      { text: `Dispatch No: ${gp.dispatch_number || gp.id || '-'}`, style: 'rightLbl' },
      { text: `Created: ${createdAtStr}`, style: 'rightLbl' }
    ];
    if (gp.dispatch_number) headerRightStack.push({ qr: gp.dispatch_number, fit: 60, margin: [0, 6, 0, 0] });

    const summaryTable = {
      table: {
        widths: ['*', '*', '*'],
        body: [
          [
            { text: `Dispatch To: ${gp.dispatch_to || '-'}` },
            { text: `Vehicle: ${gp.vehicle || '-'}` },
            { text: `Report ID(s): ${gp.report_ids || '-'}` }
          ],
          [
            { text: `Receiver: ${gp.receiver_name || '-'}` },
            { text: `Designation: ${gp.receiver_designation || '-'}` },
            { text: `Mobile: ${gp.receiver_mobile || '-'}` }
          ]
        ]
      },
      layout: 'lightHorizontalLines',
      margin: [0, 0, 0, 10]
    };

    const doc: TDocumentDefinition = {
      pageSize: 'A4',
      pageMargins: [36, 48, 36, 48],
      content: [
        {
          columns: [
            { stack: headerLeftStack },
            { alignment: 'right', stack: headerRightStack }
          ]
        },

        { canvas: [ { type: 'line', x1:0, y1:0, x2:525, y2:0, lineWidth:1 } ], margin: [0,10,0,10] },

        summaryTable,

        // Serial numbers section
        { text: `Serial Numbers (${serials.length})`, style: 'h2', margin: [0, 6, 0, 6] },
        // Comma-separated within each column
        this.buildSerialColumns(serials, columns),

        ...(deviceTable && devices?.length ? [
          // { text: 'Selected Devices', style: 'h2', margin: [0, 12, 0, 6] },
          // this.buildDeviceTable(devices)
        ] : []),

        ...(includeNotes ? [
          { text: 'Notes:', style: 'h3', margin: [0, 12, 0, 4] },
          { text: notesText, margin: [0,0,0,10] }
        ] : []),

        {
          columns: [
            { text: '\n\n____________________________\nIssued By (Signature & Name)', alignment: 'left' },
            { text: '\n\n____________________________\nReceived By (Signature & Name)', alignment: 'right' }
          ],
          margin: [0, 20, 0, 0]
        },

        ...(showFooterMeta ? [
          {
            columns: [
              { text: `Laboratory User Generated By: ${generatedBy || '-'}`, alignment: 'left' },
              { text: `Support Email: ${supportEmail}`, alignment: 'left' }
            ],
            margin: [0, 12, 0, 4]
          }
        ] : [])
      ],
      styles: {
        h1: { fontSize: 18, bold: true },
        h2: { fontSize: 14, bold: true },
        h3: { fontSize: 12, bold: true },
        sub: { fontSize: 10, color: '#666' },
        rightLbl: { fontSize: 10 },
        th: { bold: true }
      }
    };

    return doc;
  }

  // Comma-separated serials, sliced into N columns
  private buildSerialColumns(serials: string[], colCount = 3) {
    if (!serials?.length) return { text: '-' };

    const perCol = Math.ceil(serials.length / colCount);
    const cols = Array.from({ length: colCount }, (_, i) =>
      serials.slice(i * perCol, (i + 1) * perCol).join(', ')
    );

    return {
      columns: cols.map(txt => ({
        text: txt,
        fontSize: 10,
        lineHeight: 1.2,
        margin: [0, 0, 0, 0]
      })),
      columnGap: 10
    };
  }

  private buildDeviceTable(devs: GatepassDeviceRow[]) {
    const body = [
      [{ text: 'Serial No', style: 'th' }, { text: 'Make', style: 'th' }, { text: 'Result', style: 'th' }, { text: 'Status', style: 'th' }]
    ];
    devs.forEach(d => body.push([
      { text: d.serial_number || '-', style: 'th' },
      { text: d.make || '-', style: 'th' },
      { text: d.test_result || '-', style: 'th' },
      { text: d.test_status || '-', style: 'th' }
    ]));

    return {
      table: {
        headerRows: 1,
        widths: ['*', '*', 'auto', 'auto'],
        body
      },
      layout: 'lightHorizontalLines'
    };
  }

  private parseSerials(str: string): string[] {
    return (str || '')
      .split(',')
      .map(s => s.trim())
      .filter(Boolean);
  }

  private fileName(gp: GatepassData, opts: GatepassPdfOptions): string {
    if (opts.fileName) return opts.fileName.endsWith('.pdf') ? opts.fileName : `${opts.fileName}.pdf`;
    const tag = gp.dispatch_number || gp.id || 'RMTL';
    return `Gatepass_${tag}.pdf`;
  }
}



// // Inside your component after you have `gatepassInfo` and `currentUser`
// this.gpPdf.download(this.gatepassInfo, {
//   columns: 3,                 // 3 columns of comma-separated serials
//   deviceTable: false,         // set true and pass devices[] if you want a table
//   generatedBy: this.currentUser?.name,  // shows in footer
//   supportEmail: 'rmtl@mpwz.co.in'
// });

