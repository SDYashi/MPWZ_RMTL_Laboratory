import { Injectable } from '@angular/core';
import pdfMake from 'pdfmake/build/pdfmake';
import pdfFonts from 'pdfmake/build/vfs_fonts';
(pdfMake as any).vfs = pdfFonts.vfs;

type TDocumentDefinition = any;

export interface GatepassData {
  id?: string | number;
  dispatch_number?: string;
  dispatch_to?: string;
  vehicle?: string;
  report_ids?: string;
  receiver_name?: string;
  receiver_designation?: string;
  receiver_mobile?: string;
  created_by?: string;
  created_at?: string;       // ISO string
  serial_numbers?: string;   // comma-separated serials

  // Optional lab info passthrough (if you prefer attaching here)
  lab_name?: string | null;
  lab_address?: string | null;
  lab_email?: string | null;
  lab_phone?: string | null;
  leftLogoUrl?: string | null;
  rightLogoUrl?: string | null;

}

export interface GatepassDeviceRow {
  serial_number?: string;
  make?: string;
  test_result?: string;
  test_status?: string;
}

export interface GatepassHeaderInfo {
  orgLine?: string;            // e.g. 'MADHYA PRADESH PASCHIM KHETRA VIDYUT VITARAN COMPANY LIMITED'
  labLine?: string;            // e.g. 'REGIONAL METERING TESTING LABORATORY INDORE'
  addressLine?: string;        // address
  email?: string;
  phone?: string;
  leftLogoUrl?: string;        // dataURL or absolute/relative URL
  rightLogoUrl?: string;       // dataURL or absolute/relative URL
  logoWidth?: number;          // default 36
  logoHeight?: number;         // default 36
}

export interface GatepassPdfOptions {
  columns?: number;               // force serial columns; auto if omitted
  includeNotes?: boolean;         // default true
  notesText?: string;             // default standard notes
  devices?: GatepassDeviceRow[];  // optional table rows
  deviceTable?: boolean;          // default false (auto-enabled if devices present)
  fileName?: string;              // custom output filename
  generatedBy?: string;           // footer "Laboratory User Generated By"
  supportEmail?: string;          // footer support email (default 'rmtl@mpwz.co.in')
  showFooterMeta?: boolean;       // default true
  header?: GatepassHeaderInfo;    // header content + logos
}

@Injectable({ providedIn: 'root' })
export class GatepassPdfService {

  // ---------- Public API ----------
  async download(gp: GatepassData, opts: GatepassPdfOptions = {}): Promise<void> {
    const doc = await this.buildDocWithLogos(gp, opts);
    const fname = this.fileName(gp, opts);
    await new Promise<void>(res => pdfMake.createPdf(doc).download(fname, () => res()));
  }
  async open(gp: GatepassData, opts: GatepassPdfOptions = {}): Promise<void> {
    const doc = await this.buildDocWithLogos(gp, opts);
    pdfMake.createPdf(doc).open();
  }
  async print(gp: GatepassData, opts: GatepassPdfOptions = {}): Promise<void> {
    const doc = await this.buildDocWithLogos(gp, opts);
    pdfMake.createPdf(doc).print();
  }
  async getDocDefinition(gp: GatepassData, opts: GatepassPdfOptions = {}): Promise<TDocumentDefinition> {
    return this.buildDocWithLogos(gp, opts);
  }

  // ---------- Build with logo loading ----------
  private async buildDocWithLogos(gp: GatepassData, opts: GatepassPdfOptions): Promise<TDocumentDefinition> {
    const images: Record<string, string> = {};
    const h = opts.header || {};
    const isData = (u?: string) => !!u && /^data:image\/[a-zA-Z]+;base64,/.test(u);
    const toDataURL = async (url: string) => {
      const abs = new URL(url, document.baseURI).toString();
      const res = await fetch(abs, { cache: 'no-cache' });
      if (!res.ok) throw new Error(`logo fetch failed ${abs}`);
      const blob = await res.blob();
      return await new Promise<string>((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result as string);
        fr.onerror = reject;
        fr.readAsDataURL(blob);
      });
    };
    const safeLoad = async (key: 'leftLogo' | 'rightLogo', url?: string) => {
      if (!url) return;
      try { images[key] = isData(url) ? url : await toDataURL(url); } catch { /* ignore */ }
    };

    await Promise.all([
      safeLoad('leftLogo', h.leftLogoUrl),
      safeLoad('rightLogo', h.rightLogoUrl),
    ]);
    if (!images['leftLogo'] && images['rightLogo']) images['leftLogo'] = images['rightLogo'];
    if (!images['rightLogo'] && images['leftLogo']) images['rightLogo'] = images['leftLogo'];

    return this.buildDoc(gp, opts, images);
  }

  // ---------- Core doc ----------
  private buildDoc(gp: GatepassData, opts: GatepassPdfOptions, images: Record<string, string>): TDocumentDefinition {
    const {
      includeNotes = true,
      notesText = '— Carry out standard handling and verification on receipt.\n— Any discrepancy must be reported immediately.',
      deviceTable = false,
      devices,
      generatedBy,
      supportEmail = 'rmtl@mpwz.co.in',
      showFooterMeta = true,
      columns,
      header
    } = opts;

    const createdAt = gp.created_at ? new Date(gp.created_at) : new Date();
    const createdAtStr = createdAt.toLocaleString();
    const serials = this.parseSerials(gp.serial_numbers || '');

    const bestColCount = columns ?? this.pickSerialColumns(serials.length);

    const metaForHeader = {
      orgLine: (header?.orgLine || 'MADHYA PRADESH PASCHIM KHETRA VIDYUT VITARAN COMPANY LIMITED').toUpperCase(),
      labLine: (header?.labLine || gp.lab_name || 'REGIONAL METERING TESTING LABORATORY INDORE').toUpperCase(),
      addressLine: header?.addressLine || gp.lab_address || 'MPPKVVCL Near Conference Hall, Polo Ground, Indore (MP) 452003',
      email: header?.email || gp.lab_email || '-',
      phone: header?.phone || gp.lab_phone || '-',
      logoWidth: header?.logoWidth ?? 36,
      logoHeight: header?.logoHeight ?? 36,
    };

    const content: any[] = [
      this.headerBar(metaForHeader, images),
      { canvas: [{ type: 'line', x1: 28, y1: 0, x2: 567 - 28, y2: 0, lineWidth: 1 }], margin: [0, 6, 0, 6] },
      { text: 'GATEPASS', alignment: 'center', fontSize: 12, bold: true, margin: [0, 0, 0, 6] },
      this.metaBand({
        dispatch_number: gp.dispatch_number || gp.id || '-',
        created_at: createdAtStr,
        vehicle: gp.vehicle || '-',
        report_ids: gp.report_ids || '-',
        receiver_name: gp.receiver_name || '-',
        receiver_designation: gp.receiver_designation || '-',
        receiver_mobile: gp.receiver_mobile || '-',
        dispatch_to: gp.dispatch_to || '-'
      }),
      { text: `Serial Numbers (${serials.length})`, style: 'h3', margin: [28, 4, 28, 4] },
      this.serialColumns(serials, bestColCount),
    ];

    // // NEW: auto-enable device table if devices are passed
    // const showDevices = deviceTable || (devices?.length ?? 0) > 0;
    // if (showDevices) {
    //   content.push({ text: 'Selected Devices', style: 'h3', margin: [28, 10, 28, 4] });
    //   content.push(this.deviceTable(devices || []));
    // }

    if (includeNotes) {
      content.push({ text: 'Notes:', style: 'h3', margin: [28, 10, 28, 2] });
      content.push({ text: notesText, margin: [28, 0, 28, 6] });
    }

    content.push(this.signBlock());

    return {
      pageSize: 'A4',
      pageMargins: [0, 0, 0, 28], // flush header, standard bottom
      defaultStyle: { fontSize: 9, lineHeight: 1.05 },
      styles: {
        h3: { fontSize: 11, bold: true },
        lbl: { bold: true, fontSize: 9, color: '#111' },
        th: { bold: true, fontSize: 9 },
        tableTight: { fontSize: 9 },
        footRole: { fontSize: 9, bold: true },
        footTiny: { fontSize: 8, color: '#444' },
      },
      images,
      content,
      footer: (current: number, total: number) => ({
        columns: [
          { text: `Page ${current} of ${total}`, alignment: 'left', margin: [28, 0, 0, 0] },
          { text: 'M.P.P.K.V.V.CO. LTD., INDORE', alignment: 'right', margin: [0, 0, 28, 0] }
        ],
        fontSize: 8
      }),
      info: { title: `Gatepass_${gp.dispatch_number || gp.id || 'RMTL'}` }
    };
  }

  // ---------- Sections ----------
  private headerBar(meta: {
    orgLine: string; labLine: string; addressLine: string; email: string; phone: string;
    logoWidth: number; logoHeight: number;
  }, images: Record<string, string>) {
    return {
      margin: [28, 8, 28, 6],
      columns: [
        images['leftLogo'] ? { image: 'leftLogo', width: meta.logoWidth, height: meta.logoHeight } : { width: meta.logoWidth, text: '' },
        {
          width: '*',
          stack: [
            { text: meta.orgLine, alignment: 'center', bold: true, fontSize: 12 },
            { text: meta.labLine, alignment: 'center', bold: true, fontSize: 11, margin: [0, 2, 0, 0] },
            { text: meta.addressLine, alignment: 'center', fontSize: 9, margin: [0, 2, 0, 0] },
            { text: `Email: ${meta.email} • Phone: ${meta.phone}`, alignment: 'center', fontSize: 9, margin: [0, 2, 0, 0] }
          ]
        },
        images['rightLogo'] ? { image: 'rightLogo', width: meta.logoWidth, height: meta.logoHeight } : { width: meta.logoWidth, text: '' }
      ]
    };
  }

  private metaBand(g: any) {
    const lbl = { bold: true, fillColor: '#f5f5f5' };
    return {
      layout: 'noBorders',
      margin: [28, 0, 28, 8],
      table: {
        widths: ['auto','*','auto','*'],
        body: [
          [{ text: 'Dispatch No', ...lbl }, { text: g.dispatch_number }, { text: 'Created', ...lbl }, { text: g.created_at }],
          [{ text: 'Vehicle', ...lbl }, { text: g.vehicle }, { text: 'Report ID(s)', ...lbl }, { text: g.report_ids }],
          [{ text: 'Receiver', ...lbl }, { text: g.receiver_name }, { text: 'Designation', ...lbl }, { text: g.receiver_designation }],
          [{ text: 'Mobile', ...lbl }, { text: g.receiver_mobile }, { text: 'Dispatch To', ...lbl }, { text: g.dispatch_to }]
        ]
      }
    };
  }

  private serialColumns(serials: string[], colCount: number) {
    if (!serials?.length) return { text: '-', margin: [28, 0, 28, 0] };

    const perCol = Math.ceil(serials.length / colCount);
    const cols = Array.from({ length: colCount }, (_, i) =>
      serials.slice(i * perCol, (i + 1) * perCol).join(', ')
    );

    return {
      columns: cols.map(txt => ({
        text: txt,
        fontSize: 10,
        lineHeight: 1.2,
        margin: [28, 0, 10, 0]
      })),
      columnGap: 10
    };
  }

  private deviceTable(devs: GatepassDeviceRow[]) {
    const body = [
      [{ text: 'Serial No', style: 'th' }, { text: 'Make', style: 'th' }, { text: 'Result', style: 'th' }, { text: 'Status', style: 'th' }]
    ];
    devs.forEach(d => body.push([
      { text: d.serial_number || '-', style: 'td' },
      { text: d.make || '-', style: 'td' },
      { text: d.test_result || '-', style: 'td' },
      { text: d.test_status || '-', style: 'td' }
    ]));
    return {
      style: 'tableTight',
      layout: 'lightHorizontalLines',
      table: { headerRows: 1, widths: ['*','*','auto','auto'], body }
    };
  }

  private signBlock() {
    return {
      columns: [
        { width: '*', alignment: 'center', stack: [{ text: 'Issued By', style: 'footRole' }, { text: '\n____________________________', alignment: 'center' }] },
        { width: '*', alignment: 'center', stack: [{ text: 'Received By', style: 'footRole' }, { text: '\n____________________________', alignment: 'center' }] },
        // { width: '*', alignment: 'center', stack: [{ text: 'Lab Authority', style: 'footRole' }, { text: '\n____________________________', alignment: 'center' }] }
      ],
      margin: [28, 12, 28, 0]
    };
  }

  // ---------- Helpers ----------
  private parseSerials(str: string): string[] {
    return (str || '').split(',').map(s => s.trim()).filter(Boolean);
  }
  private pickSerialColumns(count: number): number {
    if (count >= 120) return 4;
    if (count >= 50) return 3;
    return 2;
  }
  private fileName(gp: GatepassData, opts: GatepassPdfOptions): string {
    if (opts.fileName) return opts.fileName.endsWith('.pdf') ? opts.fileName : `${opts.fileName}.pdf`;
    const tag = gp.dispatch_number || gp.id || 'RMTL';
    return `Gatepass_${tag}.pdf`;
  }
}
